
#include "savelayout.h"

SaveLayout::SaveLayout() {}

bool SaveLayout::saveCif(string fname, Rules &actual_rules, map<string, CLayout>& layouts, string top) {
	filename=fname;
	rules=&actual_rules;
	idx = 1;
	
	file.open(filename.c_str()); // Write
	cout << "Saving CIF file: " << fname << endl;
	if (!file)
		cerr << filename << ": CIF file could not be created" << endl;
	
	printHeader(file, "(", ");");
	file << "(CIF generated by the ICPD " << VERSION << ");\n";
	file << "(Technology : " << rules->getCIFVal(TECHNAME) << ");\n";

	instances.clear();
	cellCif(layouts,top);
	file << "E;\n";
	file.flush();
	file.close(); 

	return true;
}

bool SaveLayout::cellCif(map<string, CLayout>& layouts, string top) {
	if(layouts.find(top)==layouts.end())
		return false;

	CLayout& currentLayout=layouts[top];
	instances[currentLayout.getName()]=idx++;

	//Declara os Layouts utilizado no topo
	map<string, Instance>::iterator instances_it;
	for(instances_it=currentLayout.getInstances()->begin(); instances_it!=currentLayout.getInstances()->end(); instances_it++){
		if(instances.find(instances_it->second.getTargetCell())==instances.end())
			if(!cellCif(layouts, instances_it->second.getTargetCell()))
				return false;
	}

	//Instancia o layout atual
	file << "\nDS " << instances[currentLayout.getName()] << " 1 1;\n";
	
	file << "9 " << currentLayout.getName() << ";" << endl;
	
	//Chama as instancias
	for(instances_it=currentLayout.getInstances()->begin(); instances_it!=currentLayout.getInstances()->end(); instances_it++){
		file << "C " << instances[instances_it->second.getTargetCell()] << " ";
		if(instances_it->second.getMX()) file << "MX ";
		if(instances_it->second.getMY()) file << "MY ";
		file << "T " << instances_it->second.getX() << " " << instances_it->second.getY() << ";\n";
	}
	
	//Desenha o layout atual
	map <layer_name , list<Box> >::iterator layers_it; // iterador das camadas
	list<Label>::iterator labels_it;
	for (labels_it = currentLayout.labels.begin(); labels_it != currentLayout.labels.end(); labels_it++)
		file << "94 " << labels_it->text << " " << labels_it->pt.getX() << " "
		<< labels_it->pt.getY() << " " << rules->getCIFVal(MET1) << ";\n";
	
	list <Box>::iterator layer_it;
	for (layers_it = currentLayout.layers.begin(); layers_it != currentLayout.layers.end(); layers_it++) {
		if ( !layers_it->second.empty() ) {
			file << "L " << rules->getCIFVal(layers_it->first) << ";\n";
			for ( layer_it = layers_it->second.begin(); layer_it != layers_it->second.end(); layer_it++ )
				if ( layer_it->getHeight() > 0 && layer_it->getWidth() > 0 )
				file << "B " <<  layer_it->getWidth()  << " " <<
				layer_it->getHeight() << " " <<
				layer_it->getX()  << " " <<
				layer_it->getY()  << ";\n";
			
		}
	}
	file << "DF;\n";
	return true;
}

bool SaveLayout::saveSight(string fname, Rules &actual_rules, map<string, CLayout>& layouts, string top) {
	filename=fname;
	rules=&actual_rules;
	idx = 1;
	
	file.open(filename.c_str()); // Write
	cout << "Saving Sight file: " << fname << endl;
	if (!file)
		cerr << filename << ": Sight file could not be created" << endl;
	
	file << "define brush NWEL pattern0 0xFF00CC66 solid 0xFF00CC66\n";
	file << "define brush PWEL pattern0 0xFFFF8000 solid 0xFFFF8000\n";
	file << "define brush NSEL empty black solid 0xFF00CC66\n";
	file << "define brush PSEL empty black solid 0xFFFF8000\n";
	file << "define brush NDIF pattern2 0xFF00CC66 solid 0xFF00CC66\n";
	file << "define brush PDIF pattern2 0xFFFF8000 solid 0xFFFF8000\n";
	file << "define brush POLY pattern1 red solid red\n";
	file << "define brush CONT full 0xFFB9D3EE solid 0xFFB9D3EE\n";
	file << "define brush MET1 pattern3 blue solid blue\n";
	file << "define brush MET1P empty blue solid blue\n";
	file << "define brush VIA1 pattern2 pink solid pink\n";
	file << "define brush MET2 pattern4 pink solid pink\n";
	file << "define brush VIA2 pattern2 0xFF39BFFF solid 0xFF39BFFF\n";
	file << "define brush MET3 pattern6 0xFF32FFFF solid 0xFF32FFFF\n";
	file << "define brush CELLBOX empty black solid white\n";
	
	instances.clear();
	cellSight(layouts,top);

	file << "\ndraw group 1 0 0 0 1 1 false false 0";

	file.flush();
	file.close();

	return true;
}

bool SaveLayout::cellSight(map<string, CLayout>& layouts, string top) {
	if(layouts.find(top)==layouts.end())
		return false;
	
	CLayout& currentLayout=layouts[top];
	instances[currentLayout.getName()]=idx++;
	
	//Declara os Layouts utilizado no topo
	map<string, Instance>::iterator instances_it;
	for(instances_it=currentLayout.getInstances()->begin(); instances_it!=currentLayout.getInstances()->end(); instances_it++){
		if(instances.find(instances_it->second.getTargetCell())==instances.end())
			if(!cellSight(layouts, instances_it->second.getTargetCell()))
				return false;
	}
	
	//Instancia o layout atual
	file << "\ngroup " << instances[currentLayout.getName()] << "\n";
	
	//Chama as instancias
	for(instances_it=currentLayout.getInstances()->begin(); instances_it!=currentLayout.getInstances()->end(); instances_it++){
		file << "\tdraw group " << instances[instances_it->second.getTargetCell()] << " 0 ";
		file << instances_it->second.getX() << " " << instances_it->second.getY() << " 1 1 ";
		if(instances_it->second.getMX()) file << "true ";
		else file << "false ";
		if(instances_it->second.getMY()) file << "true ";
		else file << "false ";
		file << "0\n";
	}
	
	//Desenha o layout atual
	map <layer_name , list<Box> >::iterator layers_it; // iterador das camadas
	list<Label>::iterator labels_it;
	for (labels_it = currentLayout.labels.begin(); labels_it != currentLayout.labels.end(); labels_it++)
		file << "\tdraw text " << rules->getCIFVal(MET1) << " 9999 " << labels_it->pt.getX() << " "
		<< labels_it->pt.getY() << " " << labels_it->text << "\n";
	
	list <Box>::iterator layer_it;
	for (layers_it = currentLayout.layers.begin(); layers_it != currentLayout.layers.end(); layers_it++) {
		if ( !layers_it->second.empty() ) {
			for ( layer_it = layers_it->second.begin(); layer_it != layers_it->second.end(); layer_it++ )
				if ( layer_it->getHeight() > 0 && layer_it->getWidth() > 0 )
					file << "\tdraw rect " << rules->getLayerName(layers_it->first) << " " << layers_it->first << " " <<
					layer_it->getX1()  << " " <<
					layer_it->getY1()  << " " <<
					layer_it->getWidth()  << " " <<
					layer_it->getHeight() << " " << rules->getLayerName(layers_it->first) << "\n";			
		}
	}
	file << "end\n";
	return true;
}

bool SaveLayout::cif2Cadence(string designName, string top){
	rules->saveCIFLayerTable(getPath(filename)+"CIFLTable.txt");
	
	ofstream c2cfile;
	string c2cfilename=removeExt(filename)+".c2c";
	c2cfile.open(c2cfilename.c_str()); // Write
	cout << "Saving CIF2Cadence convertion file: " << c2cfilename << endl;
	if (!c2cfile)
		cerr << c2cfilename << ": C2C file could not be created" << endl;
	c2cfile << "  cifInKeys = list( nil  " << endl;
	c2cfile << "    'runDir                 \"./\"" << endl;
	c2cfile << "    'inFile                 \"" << getFileName(filename) << "\"" << endl;
	c2cfile << "    'primaryCell            \"" << top << "\"" << endl;
	c2cfile << "    'libName                \"" << designName << "\"" << endl;
	c2cfile << "    'dataDump               \"\"" << endl;
	c2cfile << "    'techfileName           \"tech.lib\"" << endl;
	c2cfile << "    'scale                  " << float(1)/rules->getScale() << endl;
	c2cfile << "    'units                  \"micron\""   << endl;
	c2cfile << "    'errFile                \"PIPO.LOG\"" << endl;
	c2cfile << "    'cellMapTable           \"\"" << endl;
	c2cfile << "    'layerTable             \"CIFLTable.txt\"" << endl;
	c2cfile << "    'textFontTable          \"\"" << endl;
	c2cfile << "    'userSkillFile          \"\"" << endl;
	c2cfile << "    'hierDepth              32" << endl;
	c2cfile << "    'maxVertices            1024" << endl;
	c2cfile << "    'checkPolygon           nil" << endl;
	c2cfile << "    'snapToGrid             nil" << endl;
	c2cfile << "    'caseSensitivity        \"lower\"" << endl;
	c2cfile << "    'zeroWireToLine         \"lines\"" << endl;
	c2cfile << "    'wireToPathStyle        \"extend\"" << endl;
	c2cfile << "    'roundFlashToEllipse    \"ellipse\"" << endl;
	c2cfile << "    'skipUndefinedLPP       nil" << endl;
	c2cfile << "    'reportPrecision        nil" << endl;
	c2cfile << "    'runQuiet               nil" << endl;
	c2cfile << "    'saveAtTheEnd           nil" << endl;
	c2cfile << "    'noWriteExistCell               nil" << endl;
	c2cfile << "    'NOUnmappingLayerWarning                nil" << endl;
	c2cfile << "    )" << endl;
	c2cfile.close();
	cout << "ATTENTION:" << endl;
	cout << "Copy the files: " << getFileName(c2cfilename) << ", " << getFileName(filename) << ", CIFLTable.txt, tech.lib (dump it direct from Cadence Icfb: Tools->Technology File Manager->Dump) to the root of your cadence project and than execute in the icfb menu File->Import->CIF Load: " << getFileName(c2cfilename) << endl;
	return true;
}

SaveLayout::~SaveLayout(){}